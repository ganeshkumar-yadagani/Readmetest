```java
@Autowired
private TokenGeneratorUtil tokenGeneratorUtil;

public void callDownstream() {
    AuthToken token = tokenGeneratorUtil.getCachedToken(false);
    String accessToken = token.getAccessToken();
    // Use the accessToken for downstream API call
}
```
3. Use `@ConfigurationProperties(prefix = "azure-token")` to load token config.

---

## 🔄 Token Caching Behavior

This library includes a built-in caching mechanism to **reuse valid access tokens** and reduce redundant calls to the token endpoint.

### How It Works

- The `TokenGeneratorUtil` class maintains a **cached token instance (`cachedAuthToken`)**.
- When `getCachedToken(boolean invalidateCache)` is called:
  - If:
    - `invalidateCache` is `true`, or
    - No token is currently cached (`cachedAuthToken == null`), or
    - The cached token is **expired** (`cachedAuthToken.isTokenExpired()` returns `true`),
  - Then:
    - The cache is **cleared**, and
    - A **new token** is generated by calling `generateAccessToken()`.

- Otherwise, the **cached valid token** is reused and returned.

#### Example

```java
AuthToken token = tokenGeneratorUtil.getCachedToken(false); // Uses cached token if valid
AuthToken token = tokenGeneratorUtil.getCachedToken(true);  // Forces regeneration
```

---
# 🔐 deepio-token-generator

A lightweight and production-ready Java token generation library for generating and caching **OAuth2** tokens using either **Azure AD** (with secret or certificate-based authentication) or **Basic Auth**.

## 📦 Features

- ✅ Supports OAuth2 `client_credentials` grant flow
- 🔑 Secret-based or certificate-based token generation (MSAL4J or REST)
- 🔄 Automatic token renewal using expiry time from `expires_in` or JWT `exp`
- 💾 In-memory token cache to avoid redundant requests
- ♻️ Optional token cache invalidation support
- ⚙️ Retry mechanism for transient (5xx) failures
- ☕ Compatible with Java 8+ and Spring Boot 2.7.x / 3.x

---

## ⚙️ Maven Dependency

This library is not deployed to Maven Central. Include as a local JAR or private repo dependency.

---

## 🚀 How It Works

### 1. Configuration

Example `application.yml`:
```yaml
azure-token:
  enable-cert-auth: false
  authorization: Basic ${AZURE_TOKEN_AUTHORIZATION}
  auth-host: ${AZURE_AUTH_HOST}
  auth-path: ${AZURE_AUTH_PATH}
  client-id: ${AZURE_CLIENT_ID}
  tenant-id: ${AZURE_TENANT_ID}
  public-cert-pem: ${AZURE_PUBLIC_CERT}
  private-key-pem: ${AZURE_PRIVATE_KEY}
  enable-token-cache: true
```

---

### 2. Generate and Use Token

In your consumer application:

```java
@Autowired
private TokenGeneratorUtil tokenGeneratorUtil;

// To get token (cached if valid)
AuthToken token = tokenGeneratorUtil.getCachedToken(false);
String accessToken = token.getAccessToken();
```

---

## 🧠 Token Cache Logic

Token is cached in memory as `cachedAuthToken`.

### Token Retrieval Logic
```java
public AuthToken getCachedToken(boolean invalidateCache) {
    if (invalidateCache || cachedAuthToken == null || cachedAuthToken.isTokenExpired()) {
        clearTokenCache();
        return generateAccessToken();
    }
    return cachedAuthToken;
}
```

- If `cachedAuthToken` is `null` or near expiry, a new token is generated.
- Expiry is checked via:
```java
public boolean isTokenExpired() {
    return OffsetDateTime.now(ZoneOffset.UTC).plusMinutes(5).isAfter(expireDateTime);
}
```
This ensures refresh happens **5 minutes before actual expiration**.

### Token Generation with Locking
```java
public AuthToken generateAccessToken() {
    if (cachedAuthToken != null && !cachedAuthToken.isTokenExpired()) {
        return cachedAuthToken;
    }
    lock.lock();
    try {
        // Fetch new token and cache it
    } finally {
        lock.unlock();
    }
}
```

---

## 🔄 Retry Mechanism

Built-in retry using Spring Retry:
- Retries on 5xx errors from Azure
- Controlled via `RetryTemplate` and policy beans

---

## 🛠 Java & Spring Compatibility

| Component    | Version         |
|--------------|------------------|
| Java         | 8, 11, 17 (✅ tested) |
| Spring Boot  | 2.7.x, 3.2.x      |
| MSAL4J       | ✅ supported       |
| RestTemplate | ✅ supported       |

---

## ✅ Usage in Consumer Apps

Works with:
- Spring Boot REST APIs (Java 8/11/17)
- Scheduled Jobs / Background Services
- Kafka / RabbitMQ producers needing OAuth2
- Swagger-integrated microservices

Just inject `TokenGeneratorUtil` and call:

```java
String token = tokenGeneratorUtil.getCachedToken(false).getAccessToken();
```

---

## 🧪 Testing Tip

To test expiry logic:
```java
tokenGeneratorUtil.getCachedToken(true); // Invalidate cache
```

To print UTC time while debugging:
```java
System.out.println(OffsetDateTime.now(ZoneOffset.UTC));
```

---

## 📁 Project Structure

- `AuthToken.java` → Token wrapper model
- `TokenGeneratorUtil.java` → Core token logic
- `ApiTokenConfig.java` → YAML-mapped configuration
- `HttpStatusRetryPolicy.java` → Retry strategy

---

## 🧩 Optional: Maven Shade Plugin

If you want to package the library as a fat JAR:

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-shade-plugin</artifactId>
  <version>3.4.1</version>
  <configuration>
    <createDependencyReducedPom>false</createDependencyReducedPom>
  </configuration>
</plugin>
```

---

## 📞 Support

For questions, please contact: **Ganesh Kumar Yadagani**
